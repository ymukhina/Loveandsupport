{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "f31ac877",
   "metadata": {},
   "outputs": [],
   "source": [
    "using Oscar\n",
    "using Nemo\n",
    "using StructuralIdentifiability\n",
    "using IterTools\n",
    "import StructuralIdentifiability: _reduce_mod_p, reduce_ode_mod_p, power_series_solution, ps_diff \n",
    "\n",
    "const Ptype = QQMPolyRingElem\n",
    "\n",
    "# -------- estimate support for f_min based on Theorems 1 and 2 -------- #\n",
    "\n",
    "function f_min_support_bivariate(ode::ODE)\n",
    "    @assert length(ode.x_vars) == 2 \"system has more than two variables.\"\n",
    "    x1, x2 = sort(ode.x_vars, rev = true)\n",
    "    g1 = ode.x_equations[x1]\n",
    "    g2 = ode.x_equations[x2]\n",
    "    d1 = total_degree(g1)\n",
    "    d2 = total_degree(g2)\n",
    "    if d1 <= d2\n",
    "        A = [1 d1 (d1 + d2 - 1); -1 0 0; 0 -1 0; 0 0 -1]\n",
    "        b = [d1 * (d1 + d2 - 1), 0, 0, 0]\n",
    "    else\n",
    "        A = [1 d1 (2 * d1 - 1); 1 d2 (d1 + d2 - 1); -1 0 0; 0 -1 0; 0 0 -1]\n",
    "        b = [d1*(2*d1 - 1), d1*(d1 + d2 - 1), 0, 0, 0]\n",
    "    end\n",
    "    return collect(lattice_points(polyhedron(A, b)))\n",
    "end\n",
    "\n",
    "function f_min_support(ode::ODE; info = false)\n",
    "    # I guess by sorting you try to ensure that the first x is the output, i am not sure\n",
    "    # this would always work. You could just choose x such that the only y_equation is equal to x\n",
    "    x = sort(ode.x_vars, rev = true)\n",
    "    info && @info \"Inferred order $x\"\n",
    "    n = length(x)\n",
    "    gs = [ode.x_equations[xi] for xi in x]\n",
    "    d1 = total_degree(gs[1])\n",
    "    @assert d1 > 0 \"d1 = 0\"\n",
    "    D = maximum(total_degree, gs[2:end])\n",
    "    info && @info \"We have d1 = $d1 and D = $D\"\n",
    "\n",
    "    if d1 <= D\n",
    "        ineq_lhs = reshape([1, [d1 + (k - 1) * (D - 1) for k in 1:n]...], 1, n + 1)\n",
    "        ineq_rhs = [prod([d1 + (k - 1) * (D - 1) for k in 1:n])]\n",
    "        A = vcat(matrix(QQ, ineq_lhs), -identity_matrix(QQ, n + 1))\n",
    "        b = vcat(ineq_rhs, zeros(QQ, n + 1))\n",
    "    else\n",
    "        ineq_lhs1 = [k <= l ? k * (D - 1) + 1 : 0 for l in 0:(n - 1), k in 0:n]\n",
    "        ineq_lhs2 = zeros(Int, n, n + 1)\n",
    "        for l in 0:(n - 1)\n",
    "            for i in 1:(n - l)\n",
    "                ineq_lhs2[l + 1, i + l + 1] = i * (d1 - 1) + l * (D - 1) + 1\n",
    "            end\n",
    "        end\n",
    "        ineq_rhs = [prod([d1 + (k - 1) * (D - 1) for k in 1:l]) * prod([i * (d1 - 1) + l * (D - 1) + 1 for i in 1:(n - l)])\n",
    "                    for l in 0:(n - 1)]\n",
    "        A = vcat(matrix(QQ, ineq_lhs1 + ineq_lhs2), -identity_matrix(QQ, n + 1))\n",
    "        b = vcat(ineq_rhs, zeros(QQ, n + 1))\n",
    "    end\n",
    "    return collect(lattice_points(polyhedron(A, b)))\n",
    "end\n",
    "\n",
    "# ---------------------------------------------------------------------- #\n",
    "\n",
    "\n",
    "# -------- Compute f_min using an ansatz equation -------- #\n",
    "\n",
    "function solve_with_love_and_support(ode::ODE, p::Int; info = true)\n",
    "    @assert is_probable_prime(p) \"This is not a prime number, Yulia!\"\n",
    "\n",
    "    ode_mod_p = reduce_ode_mod_p(ode, p)\n",
    "    x = sort(ode_mod_p.x_vars, rev = true)\n",
    "    n = length(x)\n",
    "    y = first(ode_mod_p.y_vars)\n",
    "    F = Nemo.Native.GF(p)\n",
    "\n",
    "    # compute Newton polytope of f_min\n",
    "    possible_supp = f_min_support(ode)\n",
    "                l = length(possible_supp)\n",
    "    info && @info \"The size of the estimates support is $(length(possible_supp))\"\n",
    "    nterms = length(possible_supp) + n\n",
    "\n",
    "    # random initial conditions\n",
    "    ic = Dict([x[i] => rand(1:p - 1) for i in 1:n]...)\n",
    "    # no parameters, no inputs\n",
    "    par = empty(ic)\n",
    "    inp = empty(Dict(x[1] => [1]))\n",
    "\n",
    "    ps_soltime = @elapsed ps_sol = power_series_solution(ode_mod_p, par, ic, inp, nterms)\n",
    "    info && @info \"Power series solution computed in $ps_soltime\"\n",
    "\n",
    "    start_system_time = time()\n",
    "    pss = [ps_sol[y]]\n",
    "    for i in 1:n\n",
    "        push!(pss, ps_diff(pss[end]))\n",
    "    end\n",
    "        \n",
    "    sort!(possible_supp, by = sum)\n",
    "    prods = eval_at_support(possible_supp, pss)\n",
    "                    \n",
    "    #prods = [prod([pss[k]^exp[k] for k in 1:length(pss)]) for exp in possible_supp]                \n",
    "\n",
    "    # Gleb: how about broadcast: pss .^ exp ?\n",
    "                \n",
    "                    \n",
    "\n",
    "    ls = matrix([coeff(pr, j) for j in 0:(nterms - n - 1), pr in prods])\n",
    "    info && @info \"System created in $(time() - start_system_time)\"\n",
    "\n",
    "    info && @info \"linear system dims $(size(ls))\"\n",
    "    \n",
    "    system_soltime = @elapsed ker = kernel(ls, side=:right)\n",
    "    info && @info \"Linear system solved in $system_soltime\"\n",
    "            dim = size(kernel(ls, side=:right))[2]\n",
    "    info && @info \"The dimension of the solution space is $(dim)\"\n",
    "                    \n",
    "    R, _ = polynomial_ring(F, [\"x1\", [\"x1^($i)\" for i in 1:n]...])\n",
    "            \n",
    "    mons = [prod([gens(R)[k]^exp[k] for k in 1:ngens(R)]) for exp in possible_supp]    \n",
    "    \n",
    "    g = gcd([sum([s * m for (s, m) in zip(ker[:, i], mons)]) for i in 1:dim])\n",
    "       \n",
    "   \n",
    "    #mons = [prod([gens(R)[k]^exp[k] for k in 1:ngens(R)]) for exp in possible_supp]\n",
    "    #g = gcd([sum([s * m for (s, m) in zip(ker[:, i], mons)]) for i in 1:dim])                  \n",
    "  \n",
    "    return g\n",
    "end\n",
    "        \n",
    "\n",
    "# -------------------------------------------------------- #\n",
    "\n",
    "\n",
    "# -------- Test function -------- #\n",
    "\n",
    "# test ansatz against IO enemy equation \n",
    "function check_ansatz(ode::ODE, p::Int)\n",
    "\n",
    "    @info \"Solving with love and support!\"\n",
    "    tim = @elapsed io_tocheck = solve_with_love_and_support(ode, p)\n",
    "    @info \"time: $(tim) seconds\"\n",
    "\n",
    "    @info \"Solving without love and support :(\"\n",
    "    tim = @elapsed io_correct = first(values(find_ioequations(ode)))\n",
    "    io_correct = _reduce_mod_p(io_correct, p)\n",
    "    @info \"time: $(tim) seconds\"\n",
    "\n",
    "    R = parent(io_tocheck)\n",
    "    S = parent(io_correct)\n",
    "\n",
    "    # the variables of io_correct\n",
    "    n = ngens(R)\n",
    "    ys = gens(S)[2 * (n - 1) + 2 : 3 * (n - 1) + 2]\n",
    "    @info \"IO variables $(ys)\"\n",
    "\n",
    "    phi = hom(R, S, ys)\n",
    "\n",
    "    quot, rem = divrem(phi(io_tocheck), io_correct)\n",
    "    return iszero(rem) && iszero(total_degree(quot))\n",
    "end\n",
    "                    \n",
    "                    \n",
    "                    \n",
    "# Counting the integer points inside guessed polytopes and the ones from the theorem\n",
    "\n",
    "function bound_difference(d1::Int, d2::Int, p::Int) # counting for systems [d1, d2, 1:p]\n",
    "            for i in 1:p\n",
    "                @info \"System | Num of the int points inside the polytope | Num of monomials in the min pol\"\n",
    "                ode = rand_ode([d1,d2,i])\n",
    "                s = size(f_min_support(ode))[1]\n",
    "                l = length(solve_with_love_and_support(ode, Int(rand_bits_prime(ZZ, 32)), info = true))            \n",
    "                @info \"[$d1,$d2,$i] | $s | $l\"\n",
    "            end      \n",
    "end\n",
    "\n",
    "\n",
    "\n",
    "# ------------------------------- #\n",
    "\n",
    "\n",
    "# -------- Helper functions -------- #\n",
    "\n",
    "#Randomize general polynomial\n",
    "function rand_poly(deg, vars)\n",
    "    result = 0\n",
    "    degs = [collect(0:deg) for v in vars]\n",
    "\n",
    "    for m in IterTools.product(degs...)\n",
    "        if sum(m) <= deg\n",
    "            monom = rand(1:5)\n",
    "            for i in 1:length(vars)\n",
    "                monom *= vars[i]^m[i]\n",
    "            end\n",
    "            result += rand(1:1000) * monom\n",
    "        end\n",
    "    end\n",
    "\n",
    "    return result\n",
    "end\n",
    "\n",
    "function rand_ode(degs::Vector{Int})\n",
    "    n = length(degs)\n",
    "    R, vars = polynomial_ring(QQ, vcat([\"x$i(t)\" for i in 1:n], [\"y(t)\"]))\n",
    "    return StructuralIdentifiability.ODE{Ptype}(\n",
    "        Dict(vars[i] => rand_poly(degs[i], vars[1:n]) for i in 1:n),\n",
    "        Dict(vars[end] => vars[1]),\n",
    "        Ptype[]\n",
    "    )\n",
    "end\n",
    "                    \n",
    "#friendly helper\n",
    "function one_thing(e, vals, cacher)\n",
    "    if !haskey(cacher, e)\n",
    "        for i in 1:length(e)\n",
    "            if e[i] != 0 #[1,?]\n",
    "                    e_love = copy(e)\n",
    "                    e_love[i] -= 1\n",
    "                    res = vals[i] * one_thing(e_love, vals, cacher)\n",
    "                    cacher[e] = res\n",
    "            end\n",
    "         end  \n",
    "    end\n",
    "    return cacher[e]\n",
    "end    \n",
    "\n",
    "# Want dictionary from supp to the evaluate value\n",
    "function eval_at_support(supp, vals)\n",
    "    s = sort(supp, by = sum) \n",
    "    cacher = Dict(s[1] => one(parent(first(vals))))\n",
    "        for e in s[2:end] #index\n",
    "            one_thing(e, vals, cacher)                 \n",
    "        end\n",
    "    return return [cacher[s] for s in supp]\n",
    "end                    \n",
    "                    \n",
    "\n",
    "# ---------------------------------- #"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Julia 1.9.3",
   "language": "julia",
   "name": "julia-1.9"
  },
  "language_info": {
   "file_extension": ".jl",
   "mimetype": "application/julia",
   "name": "julia",
   "version": "1.9.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
