"""
    kernel_blocks(ls_U, ls_L) 

Finds the kernel of the Block Lower Triangular matrix given the upper and lower block matrices 
For now only 3 Blocks A, B, C where ls_U = A and ls_L = [B|C], and the whole matrix being
A 0
B C

Generalization for more blocks will be added later.
"""
function kernel_blocks(ls_U, ls_L) 
    strt = time()
    v1 = kernel(ls_U, side=:right)

    ker = solve_linear_combinations(ls_L, v1, size(ls_U, 2))
    @info "Linear System solved in $(time() - strt)"

    return ker
end

"""
    solve_linear_combinations(ls, sol_space, k = 0)

Finds the kernel of the input linear system ls given the constraint from the previous solution space sol_space found.
Adapted to solve for the kernel of a matrix we split into [B|C] given the split index k, e.g. the following case for only a single split in the matrix (1)
             and for the kernel of a single matrix without splitting, e.g. the case where we add rows to compensate for higher dimensional solution spaces (2)

Small examples:
    M = [[A, 0], [B, C]]  <==> ker(M) = V such that V = [[v1], [v2]] and Av1 =  0 with Bv1 + Cv2 = 0       (1)
    if (1) gives solution space of dimension d > 1 ==> Create M' of size (d - 1, L_supp), solve with linear combinations of basis vectors in the sol_space (2)

"""
function solve_linear_combinations(ls, sol_space, k = 0)
    F = base_ring(ls)
    n_temp, m_temp = size(sol_space)
    ls_n, ls_tot = size(ls)
    
    if k > 0
        ls_L = ls[:, 1:k]
        ls_R = ls[:, (k+1):ls_tot]
        ls_m = ls_tot - k
    else
        ls_L = ls
        ls_R = zero(matrix_space(F, ls_n, 0))
        ls_m = 0
    end
    
    S = matrix_space(F, ls_n, ls_m + m_temp)
    aug = zero(S)    
    
    if k > 0
        aug[:, 1:ls_m] = ls_R
    end
    
    for j in 1:m_temp
        w_i = ls_L * sol_space[:, j]
        aug[:, ls_m + j] = w_i
    end
    
    v = kernel(aug, side=:right)
    if k > 0
        v2, lambs = v[1:ls_m,:], v[ls_m+1:ls_m + m_temp, :]
        ker = Matrix{eltype(sol_space)}(undef, size(sol_space, 1) + size(v2, 1), size(lambs, 2))
        for i in 1:size(lambs, 2)
            v1_lamb = sum(lambs[j, i] .* sol_space[:, j] for j in 1:size(sol_space, 2))
            ker[:, i] = vcat(v1_lamb, v2[:, i])
        end
    else
        ker = Matrix{eltype(sol_space)}(undef, size(sol_space, 1), size(v, 2))
        for i in 1:size(v, 2)
            ker[:, i] = sum(v[j, i] .* sol_space[:, j] for j in 1:size(sol_space, 2))
        end
    end
    
    return matrix_space(F, size(ker,1), size(ker,2))(ker)
end


"""
    split_supp(supp, n_splits)

This function gives a list of the indices at which we can find the last element of the sections of the support that have the same highest order of x1.

For example [[0, 0, 0], [0, 1, 0], [0, 0, 1], ....., [0, ...], [1, 0, 0], [1, 1, 0], ...., and more ....] split with n_splits = 1
This will return a list containing [k1] such that support[k1] = [0, ....] and support[k1 + 1] = [1, 0, 0]

"""
 #Assuming ordered by sort_gleb_max! 
 function split_supp(supp, n_splits)
    ks = Int[]
    start_idx = 1
    
    for target_ord in 0:(n_splits)
        next_idx = findfirst(i -> supp[i][1] > target_ord, start_idx:length(supp))
        if isnothing(next_idx)
            push!(ks, length(supp))
            break
        else
            next_idx = next_idx + start_idx - 1
            push!(ks, next_idx - 1)
            start_idx = next_idx
        end
    end
    
    return ks
end

"""
    generate_points(F, n_points, n_vars, set_x1 = false)

This function generates n_points random interpolation points in the field F and returns them as a vector of vectors.

The set_x1 flag is used to set the first variable to a specific value, e.g. 0 or epsilon(1) for the dual number vanishing degree.

"""
function generate_points(F, n_points, n_vars, set_x1 = false)
    vecs = Vector{Vector{elem_type(F)}}(undef, n_points)
    for i in 1:n_points
        vec = [rand(F) for _ in 1:(n_vars + 1)]
        if set_x1
            vec[1] = F(0)
        end
        vecs[i] = vec
    end
    return vecs
end


"""
    evaluate_at_point(F, dervs, point, minpoly_ord, support, var_to_sup, supp_to_index)

Evaluates the input interpolation point the same way as in the for loop of the original build_matrix_multipoint.
Outputs the row generated by this evaluation to set it in M.
The support is already ordered by sort_gleb_max!, i.e. ordered first by exponent of x1 in the support and then like the normal sort_gleb!
To save time and space, we pass var_to_sup and supp_to_index as arguments.

"""
# Gleb: I think there is also an assumption that the support contains the constant term, right?
function evaluate_at_point(F, dervs, point, minpoly_ord, support, var_to_sup, supp_to_index)
    evals = [derv(point...) for derv in dervs]
    lsup = length(support)
    row = zeros(F, lsup)
    row[1] = F(1)

    for j in 1:(minpoly_ord + 1)
        supp = var_to_sup(j)
        if haskey(supp_to_index, supp)
            ind = supp_to_index[supp]
            row[ind] = evals[j]
        end
    end
    
    for i in 1:lsup
        supp = support[i]
        supp_divisor = copy(supp)
        nonzero_ind = findfirst(x -> x > 0, supp_divisor)
        
        if nonzero_ind === nothing
            continue
        end


        supp_divisor[nonzero_ind] -= 1
        if all(x -> x == 0, supp_divisor)
            continue
        end

        multiplier = zeros(Int, minpoly_ord + 1)
        multiplier[nonzero_ind] += 1
        
        while !haskey(supp_to_index, supp_divisor) && any(x -> x > 0, supp_divisor)
            nonzero_ind = findfirst(x -> x > 0, supp_divisor)
            if nonzero_ind === nothing
                break
            end
            supp_divisor[nonzero_ind] -= 1
            multiplier[nonzero_ind] += 1
        end
        
        if !haskey(supp_to_index, supp_divisor)
            @info "This broke: $supp_divisor"
            error("There was something unexpected")
            continue
        end
        
        supp_div_ind = supp_to_index[supp_divisor]
        mult_ind = get(supp_to_index, multiplier, -1)
        
        if mult_ind == -1
            multiplier_eval = prod(row[2:(minpoly_ord + 2)] .^ multiplier)
        else
            multiplier_eval = row[mult_ind]
        end
        
        row[i] = row[supp_div_ind] * multiplier_eval
    end
    
    return row
end

"""
    fill_matrix(points, dervs, minpoly_ord, support, mat_m)

Creates and fills the block matrix M of size (length(support), mat_m).
The support is the reordered and/or reduced support containing only the relevant support vectors for the block in question.
dervs are the derivatives we pass as argument to evaluate_at_point and fill the matrix wrt their position in the support.
minpoly_ord is the order of the minimal polynomial.

This function is essentially the part outside the for loop that would set up the everything necessary before evaluating and 
filling in the original build_matrix_multipoint.

Inside the following for loop, we now call a function evaluate_at_point that creates the respective row for some point and set it to be the row of M.

"""
function fill_matrix(points, dervs, minpoly_ord, support, mat_m)  
    F = base_ring(parent(dervs[end]))
    support = [Vector{Int64}(p) for p in support]
    mat_n = length(points)
    
    S = matrix_space(F, mat_n, mat_m)
    M = zero(S)
    
    supp_to_index = Dict(s => i for (i, s) in enumerate(support))
    var_to_sup = var_ind -> [(k == var_ind) ? 1 : 0 for k in 1:(minpoly_ord + 1)]
    
    for i in 1:mat_n
        row = evaluate_at_point(F, dervs, points[i], minpoly_ord, support, var_to_sup, supp_to_index)
        M[i, :] = row
    end
    return M
end


"""
    make_matrix(n_vars, dervs, minpoly_ord, support, mat_n, mat_m, set_x1 = false)

Calls the various functions to generate the points needed for the evaluation method and creating the block matrix of size (mat_n, mat_m).
n_vars is the number of variables in the system and dervs are the Lie derivatives to evaluate at the points.
We pass the support and minpol_ord to fill_matrix to create the block matrix similarely to the original build_matrix_multipoint.
set_x1 is a flag to determine wether x1 should have a specific value, e.g. for now x1 = 0 or epsilon(1), a dual number vanishing for degree > 1.

This will be extended to allow setting x1 = epsilon(2) and build the rectangular matrices shaping the Block Lower Triangular matrix.
"""
function make_matrix(n_vars, dervs, minpoly_ord, support, mat_n, mat_m, set_x1 = false)
    F = base_ring(parent(dervs[end]))
    points = generate_points(F, mat_n, n_vars, set_x1)
    return fill_matrix(points, dervs, minpoly_ord, support, mat_m)
end
